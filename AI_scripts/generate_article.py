import os
import logging
import requests
import csv
from datetime import datetime
from openai import OpenAI
import requests
import re
from markdown_it import MarkdownIt
from markdown_it.renderer import RendererHTML
from PIL import Image
from io import BytesIO

# The following variables must be set as environment variables for security reasons.
# OPENAI_API_KEY
# TELEGRAM_BOT_TOKEN
# TELEGRAM_CHAT_ID
# 
# In Github, you can set them in the repository settings:
# - Go to your repository on GitHub.
# - Click on the "Settings" tab.
# - In the left sidebar, click on "Secrets and variables" and then "Actions".
# - Click the "New repository secret" button.
#
#  If you run the script locally, you can set them in the terminal before running the script.
# export OPENAI_API_KEY=""
# export TELEGRAM_BOT_TOKEN=""
# export TELEGRAM_CHAT_ID=""
# 
# If you use Windows, you can set them in the terminal before running the script.
# set OPENAI_API_KEY=""
# set TELEGRAM_BOT_TOKEN=""
# set TELEGRAM_CHAT_ID=""
# 
# If you want to set them in the script for TESTING purposes, you can uncomment the following lines.
# OPENAI_API_KEY = ""
# TELEGRAM_BOT_TOKEN = ""
# TELEGRAM_CHAT_ID = ""

# Settting the variables for managing the topics
AI_TOPICS_DIRECTORY = "AI_content/"
CSV_FILE_LIST_OF_NEW_TOPICS = "list_of_NEW_topics.csv"
CSV_FILE_LIST_OF_ARCHIVED_TOPICS = "list_of_ARCHIVED_topics.csv"

# Settting the variables for the images generated by the AI
AI_IMAGES_DIRECTORY = "assets/images/"

# Settting the variables for the articles generated by the AI
AI_ARTICLES_DIRECTORY = "_posts/"

# Settting the variables for logs
LOG_FULL_PATH = ""

# Settting the variables for the website
WEBSITE = "https://galena.es/"

# Set up logging.
# The logging configuration checks if LOG_FULL_PATH is set. 
# If it is not set, logging is configured to use the default settings, which log to the console. 
# This ensures that the script continues to run even if LOG_FULL_PATH is empty.
if LOG_FULL_PATH:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', filename=LOG_FULL_PATH, filemode='a')
else:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

logging.info("✅ Script started...")

def check_env_variable_error(var_name):
    """Checks if an environment variable is set and logs the result."""
    value = os.getenv(var_name)
    if not value:
        logging.error(f"❌ ERROR: {var_name} is missing! Please set it as an environment variable.")
        raise ValueError(f"❌ ERROR: {var_name} is missing! Please set it as an environment variable.")
    else:
        logging.info(f"✅ {var_name} successfully loaded.")
    return value

def check_env_variable_warning(var_name):
    """Checks if an environment variable is set and logs the result."""
    value = os.getenv(var_name)
    if not value:
        logging.warning(f"⚠️ WARNING: {var_name} is missing! No Telegram messages will be sent.")
        return None
    else:
        logging.info(f"✅ {var_name} successfully loaded.")
    return value

def initialize_csv(file_path):
    """Creates the CSV file if it doesn't exist, handling missing cases properly."""
    if not os.path.exists(file_path):
        with open(file_path, 'w') as file:
            logging.info(f"✅ Created new CSV file: {file_path}")
    else:
        logging.info(f"✅ CSV file already exists: {file_path}")

def send_telegram_message(bot_token, chat_id, message):
    """Sends a Telegram message."""
    if not bot_token or not chat_id:
        logging.warning("⚠️ WARNING: Telegram message not sent due to missing TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID.")
        return

    message = f"{WEBSITE}\n{message}"  # Add the website to the message

    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    data = {'chat_id': chat_id, 'text': message}
    response = requests.post(url, data=data)
    if response.status_code == 200:
        logging.info("✅ Telegram message sent successfully.")
    else:
        logging.error(f"❌ Failed to send Telegram message. Status code: {response.status_code}, Response: {response.text}")

def get_topics_create_csv_and_notify(api_key, file_path, bot_token, chat_id):
    # Fetches the next 10 topics.
    prompt = """
Objective: Generate 10 engaging and insightful topic ideas for my blog at www.galena.es, focused on exploring the world of minerals, mining, and gemstones. This blog aims to be the go-to destination for geology enthusiasts, jewelry lovers, and anyone curious about the natural world.

Requirements:

- Provide 10 unique and original topic ideas.
- Format the response in CSV style without a header, directly starting with the content.
- Constraints:
  - Topic Idea: Must be no longer than 50 characters, engaging, original, and contain no symbols or punctuation, including periods comas and hyphens.
  - Description: Must be a brief one-sentence explanation no longer than 150 characters, containing no symbols or punctuation, including periods comas and hyphens.
  - Do not number each line
  - Do not use any punctuation in the topic ideas or descriptions

Example for the Format:

Topic Idea, Description

Output Example Structure:

Understanding Mineral Veins, Learn about the formation and economic significance of mineral veins in geological structures
Gemstones and Their Origins, Explore how different gemstones are formed and the geographical regions where they are found
Mining Innovations Today, Discover the latest technological advancements in the mining industry and their impact on efficiency and safety
The Beauty of Raw Gems, Examine the natural aesthetics of raw gemstones and their unique appeal in modern jewelry design
Sustainable Gemstone Sources, Understand the importance of ethically sourced gemstones and the efforts to ensure environmental sustainability
Gold Through the Ages, Delve into the historical significance of gold and its evolving role in economy and culture
Crystal Healing Myths, Evaluate the science and beliefs behind crystals and their purported healing properties
Artisan Jewelers Stories, Explore how independent jewelers are creating unique pieces with personal and cultural narratives
Future of Mineral Exploration, Look at emerging trends in the exploration of minerals with a focus on sustainability
The Science of Gem Cutting, Learn about the precision and artistry involved in cutting gemstones to enhance their beauty and value

Additional Instructions:

- Ensure the topics are relevant to minerals, mining, or gemstones.
- Consider incorporating current trends, scientific discoveries, or historical perspectives.
- Aim to provide value to both industry experts and curious learners.
"""
    client = OpenAI(
            api_key=api_key,  # Pass the api_key directly
        )    
    response = client.chat.completions.create(
    model="gpt-4",
    messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=500,
        # The max_tokens parameter controls the length of the generated output 
        # by specifying the maximum number of tokens the model is allowed to produce.
        n=1,
        # The n parameter specifies how many different completion choices the model should generate. 
        # By setting n=1, the function instructs the model to produce only one completion choice for the given input. 
        # This is useful when you want a single, straightforward response without additional alternatives.
        temperature=0.7,
        # The temperature parameter controls the randomness of the output.
        # A value of 0.7 is chosen to balance creativity and coherence.
    )
    topics = response.choices[0].message.content.strip()
    logging.info(topics)
    
    # Write topics to the CSV file
    with open(file_path, 'a') as file:
        writer = csv.writer(file)
        for line in topics.split('\n'):
            # Clean the line using regular expressions
            cleaned_line = re.sub(r'["“”]', '', line).strip()
            writer.writerow(cleaned_line.split(', '))
    
    if topics:
        logging.info("✅ 10 topics were written to CSV file.")
        send_telegram_message(bot_token, chat_id, "New 10 topics have been generated and saved.")
    else:
        logging.error("❌ Failed to generate 10 topics.")
    
    return topics

def fetch_topic_and_description(file_path, api_key, bot_token, chat_id):
    #Fetches the next blog Topic Idea and Description from the CSV.
    with open(file_path, 'r') as infile:
        reader = csv.reader(infile)
        lines = list(reader)

    if not lines:
        logging.info("CSV is empty, generating new topics...")
        get_topics_create_csv_and_notify(api_key, file_path, bot_token, chat_id)
        return fetch_topic_and_description(file_path, api_key, bot_token, chat_id)

    topic_idea, description = lines[0]
    # Remove the used line
    with open(file_path, 'w', newline='') as outfile:
        writer = csv.writer(outfile)
        writer.writerows(lines[1:])
    return topic_idea, description

def get_image_create_file_and_notify(api_key, file_path, bot_token, chat_id, topic_idea, description):
    prompt = f"""
Task:
Create an engaging illustration for a blog article on our website, ensuring it visually captures the essence of the topic provided.

Details:

    Topic Idea: {topic_idea}
    Description: {description}

Requirements:
    Focus: Highlight the mineral, emphasizing its distinctive features.
    Visual Style: Use a vibrant, educational style to capture attention.
    Audience: Designed for geology fans, educators, and earth science readers.
    Digital Quality: Optimize for digital display and printing, without guidance texts.
    Text-Free: Keep the image free of text, captions, and watermarks.
"""
    client = OpenAI(
        api_key=api_key,  # Pass the api_key directly
    )
    response = client.images.generate(
        model="dall-e-3",
        prompt=prompt,
        n=1,
        size='1024x1024'  # other options '256x256', '512x512', '1024x1024', '1024x1792', '1792x1024'
        temperature=0.8,
    )
    # Extract the URL of the generated image
    image_url = response.data[0].url
    logging.info("Generated Image URL: " + image_url)

    # Download the original image
    image_response = requests.get(image_url)
    if image_response.status_code == 200:
        original_image_path = os.path.join(file_path, f"{topic_idea.replace(' ', '_')}_1024x1024.png")
        with open(original_image_path, 'wb') as image_file:
            image_file.write(image_response.content)
        logging.info(f"✅ Original image downloaded and saved to {original_image_path}")
        
        # Resize the image
        with Image.open(BytesIO(image_response.content)) as original_image:
            resized_dimensions = (512, 512)  # Change dimensions as required
            resized_image = original_image.resize(resized_dimensions)
            
            # Save the resized image
            resized_image_path = os.path.join(file_path, f"{topic_idea.replace(' ', '_')}.png")
            resized_image.save(resized_image_path)
            logging.info(f"✅ Resized image saved to {resized_image_path}")
    else:
        logging.error(f"❌ Failed to download image. Status code: {image_response.status_code}")
        return None

    # Notify via Telegram
    send_telegram_message(bot_token, chat_id, f"New image for '{topic_idea}' has been generated and saved.")

    return resized_image_path

def get_article_content(api_key, topic_idea, description, image_path, bot_token, chat_id):
    prompt = f"""
Create a blog article of approximately 1200 words in GitHub Flavored Markdown format. 
The article is for a blog related to the world of minerals, mining, or gemstones. 
The Audience: Geology enthusiasts, educators, and general readers interested in earth sciences

- Topic Idea: {topic_idea}
- Description: {description}

Below the required structure and elements::

**Front Matter**: Begin the article with the following front matter format:
   ---
   layout: post
   title: "<title of the generated article, do not use any symbol in the title, max 50 characters>"
   subtitle: "<summary of the generated article, max 140 characters>"
   excerpt_image: {WEBSITE}{image_path}
   categories: [<2 categories, comma separated for the generated article>]
   tags: [<4 keywords, comma separated for the generated article>]
   ---
![banner]({WEBSITE}{image_path})

**Content**:
   - **Introduction**: Captivating introduction.
   - **Main Sections**: Detailed exploration and insights into topic.
   - **Quote**: Include a quote.
   - **Visual Elements**: A table to organize data or highlight key comparisons.
**External Reference**: External link reference to a verified and relevant resource.
**Conclusion**: Wrap up the article with a conclusion.
"""
    client = OpenAI(
            api_key=api_key,  # Pass the api_key directly
        )    
    response = client.chat.completions.create(
     model="gpt-4",
     messages=[
         {"role": "system", "content": "You are a helpful assistant."},
         {"role": "user", "content": prompt}
     ],
     max_tokens=3000,
     n=1,
     temperature=0.7,
 )
    article_content = response.choices[0].message.content.strip()

    # Remove any additional text like ```markdown
    article_content = article_content.replace('```markdown', '').replace('```', '').replace('``', '').strip()
    
    # Remove the first empty line if it exists
    lines = article_content.split('\n')
    if lines[0].strip() == '':
        lines = lines[1:]
    article_content = '\n'.join(lines)

    # Get the current date in YYYY-MM-DD format
    current_date = datetime.now().strftime("%Y-%m-%d")

    # Save the article content to a file with the date in the file name
    article_file_path = os.path.join(AI_ARTICLES_DIRECTORY, f"{current_date}-{topic_idea.replace(' ', '_')}.md")
    with open(article_file_path, 'w') as article_file:
        article_file.write(article_content)
    logging.info(f"✅ Article for '{topic_idea}' created and saved to {article_file_path}")
    
    # Extract categories from the front matter
    categories = re.search(r'categories: \[(.*?)\]', article_content).group(1).replace(' ', '').split(',')
    category_path = '/'.join(categories).lower()

    # Construct the article URL
    article_url = f"{WEBSITE}/{category_path}/{current_date.replace('-', '/')}/{topic_idea.replace(' ', '_')}.html"
    
    # Notify via Telegram with the full URL of the article
    send_telegram_message(bot_token, chat_id, f"New article for '{topic_idea}' has been generated and saved. Read it here: {article_url}")
    
    return article_file_path

def check_and_load_env_variables():
    logging.info("🔍 Checking environment variables...")
    OPENAI_API_KEY = check_env_variable_error("OPENAI_API_KEY")
    TELEGRAM_BOT_TOKEN = check_env_variable_warning("TELEGRAM_BOT_TOKEN")
    TELEGRAM_CHAT_ID = check_env_variable_warning("TELEGRAM_CHAT_ID")
    return OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID

def ensure_directories_exist(*directories):
    for directory in directories:
        os.makedirs(directory, exist_ok=True)
        logging.info(f"✅ Ensured directory exists: {directory}")
    return directories

def initialize_files(*file_paths):
    for file_path in file_paths:
        initialize_csv(file_path)
    return file_paths

def create_article_with_image(api_key, bot_token, chat_id, file_path_new, file_path_archived):
    logging.info("🔄 Fetch the next topic idea and description...")
    # Fetch the next topic idea and description
    topic_idea, description = fetch_topic_and_description(file_path_new, api_key, bot_token, chat_id)
    
    logging.info("🔄 Use the topic idea and description to request an image...")
    # Use the topic idea and description to request an image
    image_path = get_image_create_file_and_notify(api_key, AI_IMAGES_DIRECTORY, bot_token, chat_id, topic_idea, description)
    
    logging.info("🔄 Request the article content...")
    # Request the article content
    article_file_path = get_article_content(api_key, topic_idea, description, image_path, bot_token, chat_id)
    
    logging.info("🔄 Add the topic idea and description to the archived topics file...")
    # Add the topic idea and description to the archived topics file
    with open(file_path_archived, 'a') as archived_file:
        writer = csv.writer(archived_file)
        writer.writerow([topic_idea, description])
    
    logging.info("🔄 Remove the used line from the new topics file...")
    # Remove the used line from the new topics file
    with open(file_path_new, 'r') as new_file:
        lines = new_file.readlines()
    with open(file_path_new, 'w') as new_file:
        new_file.writelines(lines[1:])
    
    logging.info(f"✅ Topic '{topic_idea}' archived and removed from new topics.")

def main():
    OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID = check_and_load_env_variables()
    ensure_directories_exist(AI_TOPICS_DIRECTORY, AI_IMAGES_DIRECTORY, AI_ARTICLES_DIRECTORY)
    FILE_PATH_NEW_TOPICS, FILE_PATH_ARCHIVED_TOPICS = initialize_files(
        os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_NEW_TOPICS),
        os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_ARCHIVED_TOPICS)
    )

    logging.info("🔄 Initializing OpenAI requests...")
    # get_topics_create_csv_and_notify(OPENAI_API_KEY, FILE_PATH_NEW, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID)
    create_article_with_image(OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, FILE_PATH_NEW_TOPICS, FILE_PATH_ARCHIVED_TOPICS)

if __name__ == "__main__":
    main()
