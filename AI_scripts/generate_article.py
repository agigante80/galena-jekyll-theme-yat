import os
import logging
import requests
import csv
from datetime import datetime
from openai import OpenAI
import requests
import re
from markdown_it import MarkdownIt
from markdown_it.renderer import RendererHTML
from PIL import Image
from io import BytesIO

# The following variables must be set as environment variables for security reasons.
# OPENAI_API_KEY
# TELEGRAM_BOT_TOKEN
# TELEGRAM_CHAT_ID
# INDEXNOW_API_KEY
#
# INDEXNOW_API_KEY is the variables for the IndexNow API
# This is your own IndexNow API key. You can get it at https://indexnow.org/
# If you don't want to use IndexNow, you can leave this variable empty.
#
# In Github, you can set them in the repository settings:
# - Go to your repository on GitHub.
# - Click on the "Settings" tab.
# - In the left sidebar, click on "Secrets and variables" and then "Actions".
# - Click the "New repository secret" button.
#
#  If you run the script locally, you can set them in the terminal before running the script.
# export OPENAI_API_KEY=""
# export TELEGRAM_BOT_TOKEN=""
# export TELEGRAM_CHAT_ID=""
# 
# If you use Windows, you can set them in the terminal before running the script.
# set OPENAI_API_KEY=""
# set TELEGRAM_BOT_TOKEN=""
# set TELEGRAM_CHAT_ID=""
# 
# If you want to set them in the script for TESTING purposes, you can uncomment the following lines.
# OPENAI_API_KEY = ""
# TELEGRAM_BOT_TOKEN = ""
# TELEGRAM_CHAT_ID = ""

# Settting the variables for managing the topics
AI_TOPICS_DIRECTORY = "AI_content/"
CSV_FILE_LIST_OF_NEW_TOPICS = "list_of_NEW_topics.csv"
CSV_FILE_LIST_OF_ARCHIVED_TOPICS = "list_of_ARCHIVED_topics.csv"
CSV_FILE_LIST_OF_ERROR_TOPICS = "list_of_ERROR_topics.csv"

# Settting the variables for the images generated by the AI
AI_IMAGES_DIRECTORY = "assets/images/"

# Settting the variables for the articles generated by the AI
AI_ARTICLES_DIRECTORY = "_posts/"

# Settting the variables for logs
LOG_FULL_PATH = ""

# Settting the variables for the website
WEBSITE = "https://galena.es/"

# Set up logging.
# The logging configuration checks if LOG_FULL_PATH is set. 
# If it is not set, logging is configured to use the default settings, which log to the console. 
# This ensures that the script continues to run even if LOG_FULL_PATH is empty.
if LOG_FULL_PATH:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', filename=LOG_FULL_PATH, filemode='a')
else:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

logging.info("‚úÖ Script started...")

def check_env_variable_error(var_name):
    """Checks if an environment variable is set and logs the result."""
    value = os.getenv(var_name)
    if not value:
        logging.error(f"‚ùå ERROR: {var_name} is missing! Please set it as an environment variable.")
        raise ValueError(f"‚ùå ERROR: {var_name} is missing! Please set it as an environment variable.")
    else:
        logging.info(f"‚úÖ {var_name} successfully loaded.")
    return value

def check_env_variable_warning(var_name):
    """Checks if an environment variable is set and logs the result."""
    value = os.getenv(var_name)
    if not value:
        logging.warning(f"‚ö†Ô∏è WARNING: {var_name} is missing! Please set it as an environment variable.")
        return None
    else:
        logging.info(f"‚úÖ {var_name} successfully loaded.")
    return value

def initialize_csv(file_path):
    """Creates the CSV file if it doesn't exist, handling missing cases properly."""
    try:
        if not os.path.exists(file_path):
            with open(file_path, 'w', newline='') as file:
                logging.info(f"‚úÖ Created new CSV file: {file_path}")
        else:
            logging.info(f"‚úÖ CSV file already exists: {file_path}")
    except Exception as e:
        logging.error(f"‚ùå Failed to initialize CSV file: {file_path}. Error: {e}")

def write_to_error_file(file_path_error, topic_idea, description):
    try:
        with open(file_path_error, 'a', newline='') as error_file:
            writer = csv.writer(error_file)
            logging.info(f"Writing to error file: {file_path_error} -> {topic_idea}, {description}")
            writer.writerow([topic_idea, description])
        logging.info(f"‚úÖ Topic: '{topic_idea}', Description: '{description}' moved to ERROR topics file: {file_path_error}")
    except Exception as file_error:
        logging.error(f"‚ùå Failed to write to error file: {file_path_error}. Error: {file_error}")
        raise

def send_telegram_message(bot_token, chat_id, message):
    """Sends a Telegram message."""
    if not bot_token or not chat_id:
        logging.warning("‚ö†Ô∏è WARNING: Telegram message not sent due to missing TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID.")
        return

    message = f"{WEBSITE}\n{message}"  # Add the website to the message

    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    data = {'chat_id': chat_id, 'text': message}
    response = requests.post(url, data=data)
    if response.status_code == 200:
        logging.info("‚úÖ Telegram message sent successfully.")
    else:
        logging.error(f"‚ùå Failed to send Telegram message. Status code: {response.status_code}, Response: {response.text}")

def get_topics_create_csv_and_notify(api_key, file_path, bot_token, chat_id):
    # Fetches the next 10 topics.
    prompt = """
Objective: Generate 10 engaging and insightful topic ideas for my blog at www.galena.es, focused on exploring the world of minerals, mining, and gemstones. This blog aims to be the go-to destination for geology enthusiasts, jewelry lovers, and anyone curious about the natural world.

Requirements:

- Provide 10 unique and original topic ideas.
- Format the response in CSV style without a header, directly starting with the content.
- Constraints:
  - Topic Idea: Must be no longer than 50 characters, engaging, original, and contain no symbols or punctuation, including periods comas and hyphens.
  - Description: Must be a brief one-sentence explanation no longer than 150 characters, containing no symbols or punctuation, including periods comas and hyphens.
  - Do not number each line
  - Do not use any punctuation in the topic ideas or descriptions

Example for the Format:

Topic Idea, Description

Output Example Structure:

Understanding Mineral Veins, Learn about the formation and economic significance of mineral veins in geological structures
Gemstones and Their Origins, Explore how different gemstones are formed and the geographical regions where they are found
Mining Innovations Today, Discover the latest technological advancements in the mining industry and their impact on efficiency and safety
The Beauty of Raw Gems, Examine the natural aesthetics of raw gemstones and their unique appeal in modern jewelry design
Sustainable Gemstone Sources, Understand the importance of ethically sourced gemstones and the efforts to ensure environmental sustainability
Gold Through the Ages, Delve into the historical significance of gold and its evolving role in economy and culture
Crystal Healing Myths, Evaluate the science and beliefs behind crystals and their purported healing properties
Artisan Jewelers Stories, Explore how independent jewelers are creating unique pieces with personal and cultural narratives
Future of Mineral Exploration, Look at emerging trends in the exploration of minerals with a focus on sustainability
The Science of Gem Cutting, Learn about the precision and artistry involved in cutting gemstones to enhance their beauty and value

Additional Instructions:

- Ensure the topics are relevant to minerals, mining, or gemstones.
- Consider incorporating current trends, scientific discoveries, or historical perspectives.
- Aim to provide value to both industry experts and curious learners.
"""
    client = OpenAI(
            api_key=api_key,  # Pass the api_key directly
        )    
    response = client.chat.completions.create(
    model="gpt-4",
    messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=500,
        # The max_tokens parameter controls the length of the generated output 
        # by specifying the maximum number of tokens the model is allowed to produce.
        n=1,
        # The n parameter specifies how many different completion choices the model should generate. 
        # By setting n=1, the function instructs the model to produce only one completion choice for the given input. 
        # This is useful when you want a single, straightforward response without additional alternatives.
        temperature=0.7,
        # The temperature parameter controls the randomness of the output.
        # A value of 0.7 is chosen to balance creativity and coherence.
    )
    topics = response.choices[0].message.content.strip()
    logging.info(topics)
    
    # Write topics to the CSV file
    with open(file_path, 'a') as file:
        writer = csv.writer(file)
        for line in topics.split('\n'):
            # Clean the line using regular expressions
            cleaned_line = re.sub(r'["‚Äú‚Äù]', '', line).strip()
            writer.writerow(cleaned_line.split(', '))
    
    if topics:
        logging.info("‚úÖ 10 topics were written to CSV file.")
        send_telegram_message(bot_token, chat_id, "New 10 topics have been generated and saved.")
    else:
        logging.error("‚ùå Failed to generate 10 topics.")
    
    return topics

def fetch_topic_and_description(file_path, api_key, bot_token, chat_id):
    #Fetches the next blog Topic Idea and Description from the CSV.
    with open(file_path, 'r') as infile:
        reader = csv.reader(infile)
        lines = list(reader)

    if not lines:
        logging.info("üîÑ CSV is empty, generating new topics...")
        get_topics_create_csv_and_notify(api_key, file_path, bot_token, chat_id)
        return fetch_topic_and_description(file_path, api_key, bot_token, chat_id)

    topic_idea, description = lines[0]
    # Remove the used line
    with open(file_path, 'w', newline='') as outfile:
        writer = csv.writer(outfile)
        writer.writerows(lines[1:])
    return topic_idea, description

def get_image_create_file_and_notify(api_key, file_path, bot_token, chat_id, topic_idea, description):
    prompt = f"""
Task:
Create an engaging illustration for a blog article on our website, ensuring it visually captures the essence of the topic provided.

Details:

    Topic Idea: {topic_idea}
    Description: {description}

Requirements:
    Focus: Highlight the mineral, emphasizing its distinctive features.
    Visual Style: Use a vibrant, educational style to capture attention.
    Audience: Designed for geology fans, educators, and earth science readers.
    Digital Quality: Optimize for digital display and printing, without guidance texts.
    Text-Free: Keep the image free of text, captions, and watermarks.
"""
    client = OpenAI(
        api_key=api_key,  # Pass the api_key directly
    )
    response = client.images.generate(
        model="dall-e-3",
        prompt=prompt,
        n=1,
        size='1024x1024',  # other options '256x256', '512x512', '1024x1024', '1024x1792', '1792x1024'
    )
    # Extract the URL of the generated image
    image_url = response.data[0].url
    logging.info("üîÑ Generated Image URL: " + image_url)

    # Download the original image
    image_response = requests.get(image_url)
    if image_response.status_code == 200:
        sanitized_topic = topic_idea.replace(' ', '_').replace("'", "")
        original_image_path = os.path.join(file_path, f"{sanitized_topic}_1024x1024.png")
        with open(original_image_path, 'wb') as image_file:
            image_file.write(image_response.content)
        logging.info(f"‚úÖ Original image downloaded and saved to {original_image_path}")
        
        # Resize the image
        with Image.open(BytesIO(image_response.content)) as original_image:
            resized_dimensions = (512, 512)  # Change dimensions as required
            resized_image = original_image.resize(resized_dimensions)
            
            # Save the resized image
            resized_image_path = os.path.join(file_path, f"{sanitized_topic}.png")
            resized_image.save(resized_image_path)
            logging.info(f"‚úÖ Resized image saved to {resized_image_path}")
    else:
        logging.error(f"‚ùå Failed to download image. Status code: {image_response.status_code}")
        return None

    # Notify via Telegram
    # uncomment the following line to send a Telegram message
    # send_telegram_message(bot_token, chat_id, f"New image for '{topic_idea}' has been generated and saved.")

    return resized_image_path

def generate_image_alt_text(api_key, topic_idea, description):
    """Generate an alt text for an image based on the topic idea and description."""
    prompt = f"""
Create a concise and descriptive alt text for an image related to the following:

- Topic Idea: {topic_idea}
- Description: {description}

The blog focuses on minerals, mining, or gemstones. The audience includes geology enthusiasts, educators, and general readers interested in earth sciences.
"""

    client = OpenAI(api_key=api_key)    
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=100,
        n=1,
        temperature=0.5,
    )

    # Extract and clean the alt text by removing "Alt text: " if present
    image_alt_text = response.choices[0].message.content.strip()
    image_alt_text = image_alt_text.replace("Alt text: ", "").replace("Alt Text: ", "").replace("alt text: ", "").strip()

    logging.info(f"‚úÖ Generated alt text: {image_alt_text}")
    return image_alt_text


def notify_indexnow(api_key, url):
    indexnow_servers = [
        "https://api.indexnow.org/indexnow",
        "https://www.bing.com/indexnow",
        "https://searchadvisor.naver.com/indexnow",
        "https://search.seznam.cz/indexnow",
        "https://yandex.com/indexnow",
        "https://indexnow.yep.com/indexnow"
    ]

    # Check if running in GitHub Actions
    #if os.getenv('GITHUB_ACTIONS') == 'true':
    #    # Check if the {api_key}.txt file exists and contains the correct key
    #    key_file_path = f"{api_key}.txt"
    #    if not os.path.exists(key_file_path) or open(key_file_path).read().strip() != api_key:
    #        with open(key_file_path, 'w') as key_file:
    #            key_file.write(api_key)
    #        logging.info(f"‚úÖ Created or updated IndexNow file: {key_file_path}")

    for server_url in indexnow_servers:
        try:
            full_url = f"{server_url}?url={url}&key={api_key}"
            response = requests.get(full_url)
            logging.info(f"üîÑ Sent GET request to {full_url}")
            logging.info(f"‚úÖ Response Status Code: {response.status_code}")
            logging.info(f"‚úÖ Response Text: {response.text}")

            if not response.ok:
                logging.warning(f"‚ùå Request to {server_url} failed.")

        except requests.exceptions.RequestException as e:
            logging.error("‚ùå Request to %s failed: %s", server_url, e)

    return True  # Indicate that all requests were sent successfully

def get_article_content(api_key, topic_idea, description, image_path):
    # Generate alt text for the image
    image_alt_text = generate_image_alt_text(api_key, topic_idea, description)

    prompt = f"""
    Create a blog article of approximately between 1200 to 2000 words in GitHub Flavored Markdown format.
    The article is for a blog related to the world of minerals, mining, or gemstones.
    The Audience: Geology enthusiasts, educators, and general readers interested in earth sciences
    
    - Topic Idea: {topic_idea}
    - Description: {description}
     
    **Front Matter**: Begin the article with the following front matter format:
       ---
       layout: post
       title: "<title of the generated article, do not use any symbol in the title, max 50 characters>"
       subtitle: "<summary of the generated article, max 140 characters>"
       excerpt_image: {WEBSITE}{image_path}
       categories: [<2 categories, comma separated for the generated article>]
       tags: [<4 keywords, comma separated for the generated article>]
       ---

    ![banner]({WEBSITE}{image_path} "{image_alt_text}")

    **Content**:
       - **Introduction**: Captivating introduction.
       - **Main Sections**: Detailed exploration and insights into topic.
       - **Quote**: Include a quote.
       - **Visual Elements**: A table to organize data or highlight key comparisons.
    **External Reference**: External link reference to a verified and relevant resource.
    **Conclusion**: Wrap up the article with a conclusion.
    """
    client = OpenAI(api_key=api_key)    
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=3000,
        n=1,
        temperature=0.7,
    )
    article_content = response.choices[0].message.content.strip()

    article_content = article_content.replace('```markdown', '').replace('```', '').replace('``', '').strip()
    
    lines = article_content.split('\n')
    if lines[0].strip() == '':
        lines = lines[1:]
    article_content = '\n'.join(lines)

    current_date = datetime.now().strftime("%Y-%m-%d")
    article_file_path = os.path.join(AI_ARTICLES_DIRECTORY, f"{current_date}-{topic_idea.replace(' ', '_').replace("'", '')}.md")
    with open(article_file_path, 'w') as article_file:
        article_file.write(article_content)
    logging.info(f"‚úÖ Article for '{topic_idea}' created and saved to {article_file_path}")

    return article_file_path

def check_and_load_env_variables():
    logging.info("üîç Checking environment variables...")
    OPENAI_API_KEY = check_env_variable_error("OPENAI_API_KEY")
    TELEGRAM_BOT_TOKEN = check_env_variable_warning("TELEGRAM_BOT_TOKEN")
    TELEGRAM_CHAT_ID = check_env_variable_warning("TELEGRAM_CHAT_ID")
    INDEXNOW_API_KEY = check_env_variable_warning("INDEXNOW_API_KEY")
    return OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, INDEXNOW_API_KEY

def ensure_directories_exist(*directories):
    for directory in directories:
        os.makedirs(directory, exist_ok=True)
        logging.info(f"‚úÖ Ensured directory exists: {directory}")
    return directories

def initialize_files(*file_paths):
    for file_path in file_paths:
        initialize_csv(file_path)
    return file_paths

def create_article_with_image(api_key, bot_token, chat_id, file_path_new, file_path_archived, file_path_error, indexnow_api_key):
    exception_count = 0  # Counter to track the number of exceptions
    max_exceptions = 3  # Maximum number of allowed exceptions

    while exception_count < max_exceptions:
        logging.info("üîÑ Fetch the next topic idea and description...")
        # Fetch the next topic idea and description
        topic_idea, description = fetch_topic_and_description(file_path_new, api_key, bot_token, chat_id)
        
        logging.info(f"üîÑ Topic Idea: {topic_idea}, Description: {description}")

        try:
            logging.info("üîÑ Use the topic idea and description to request an image...")
            # Use the topic idea and description to request an image
            image_path = get_image_create_file_and_notify(api_key, AI_IMAGES_DIRECTORY, bot_token, chat_id, topic_idea, description)
            
            logging.info("üîÑ Request the article content...")
            # Request the article content
            article_file_path = get_article_content(api_key, topic_idea, description, image_path)
            
            logging.info("üîÑ Add the topic idea and description to the archived topics file...")
            # Add the topic idea and description to the archived topics file
            with open(file_path_archived, 'a') as archived_file:
                writer = csv.writer(archived_file)
                writer.writerow([topic_idea, description])
            
            logging.info("üîÑ Remove the used line from the new topics file...")
            # Remove the used line from the new topics file
            with open(file_path_new, 'r') as new_file:
                lines = new_file.readlines()
            with open(file_path_new, 'w') as new_file:
                new_file.writelines(lines[1:])
            
            logging.info(f"‚úÖ Topic '{topic_idea}' archived and removed from new topics.")

            # MOVED: Construct article URL and notify via Telegram & IndexNow here (at the end of create_article_with_image)
            current_date = datetime.now().strftime("%Y-%m-%d")
            
            with open(article_file_path, 'r') as file:
                article_content = file.read()

            # Extract categories from the front matter
            categories_match = re.search(r'categories: \[(.*?)\]', article_content)
            if categories_match:
                categories = [category.strip() for category in categories_match.group(1).split(',')]
                categories = [category.replace(' ', '%20').replace('&', '%26') for category in categories]
                category_path = '/'.join(categories).lower()
            else:
                category_path = "articles"  # default fallback if categories extraction fails
                logging.warning("‚ö†Ô∏è Categories extraction failed. Defaulted to /articles.")

            # Construct URL for your blog's format
            article_url = f"{WEBSITE}{category_path}/{current_date.replace('-', '/')}/{topic_idea.replace(' ', '_')}.html"

            # Replace single quotes with an empty string as required
            article_url = article_url.replace("'", '')

            send_telegram_message(bot_token, chat_id, f"New article for '{topic_idea}' has been generated and saved. Read it here: {article_url}")

            if indexnow_api_key:
                notify_indexnow(api_key=indexnow_api_key, url=article_url)
            else:
                logging.warning("‚ö†Ô∏è No INDEXNOW_API_KEY found. IndexNow notification will not be sent.")

            break  # Exit the loop if successful

        except Exception as e:
            exception_count += 1  # Increment the exception counter
            logging.error(f"‚ùå Error occurred: {e}")
            
            # Move the topic to the ERROR topics file
            logging.info("üîÑ Moving the topic to ERROR topics...")
            write_to_error_file(file_path_error, topic_idea, description)
            
            # Send a Telegram message about the error
            send_telegram_message(bot_token, chat_id, f"‚ùå Error occurred while processing topic '{topic_idea}'. Moved to ERROR topics. Error: {e}")

    if exception_count >= max_exceptions:
        logging.error(f"‚ùå Maximum number of exceptions ({max_exceptions}) reached. Stopping the process.")
        send_telegram_message(bot_token, chat_id, f"‚ùå Maximum number of exceptions ({max_exceptions}) reached. Stopping the process.")

def main():
    OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, INDEXNOW_API_KEY = check_and_load_env_variables()
    ensure_directories_exist(AI_TOPICS_DIRECTORY, AI_IMAGES_DIRECTORY, AI_ARTICLES_DIRECTORY)
    
    # Initialize all required CSV files, including the error topics file
    FILE_PATH_NEW_TOPICS = os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_NEW_TOPICS)
    FILE_PATH_ARCHIVED_TOPICS = os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_ARCHIVED_TOPICS)
    FILE_PATH_ERROR_TOPICS = os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_ERROR_TOPICS)

    # Ensure the files are created if they don't exist
    initialize_csv(FILE_PATH_NEW_TOPICS)
    initialize_csv(FILE_PATH_ARCHIVED_TOPICS)
    initialize_csv(FILE_PATH_ERROR_TOPICS)

    logging.info("üîÑ Initializing OpenAI requests...")
    create_article_with_image(
        OPENAI_API_KEY, 
        TELEGRAM_BOT_TOKEN, 
        TELEGRAM_CHAT_ID, 
        FILE_PATH_NEW_TOPICS, 
        FILE_PATH_ARCHIVED_TOPICS, 
        FILE_PATH_ERROR_TOPICS, 
        INDEXNOW_API_KEY
    )
    logging.info("‚úÖ Script completed!")

if __name__ == "__main__":
    main()